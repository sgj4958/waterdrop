<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>비오는 날, 창문에 맺힌 빗방울</title>
  <style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}
	html, body {width: 100%; height: 100%;}
	canvas {display: none;}
	.glass {
		width: 100%;
		height: 100%;
		position: relative;
		overflow: hidden;
	}
	.drops {
		width: 100%;
		height: 100%;
		position: relative;
		display: flex;
		justify-content: center;
		align-items: center;
		backdrop-filter: blur(15px);

		.drop {
			position: absolute;
			width: 150px;
			height: 150px;
			/* box-shadow: 
				inset 10px 10px 10px rgba(0,0,0,0.05),
				15px 25px 10px rgba(0,0,0,0.1),
				15px 20px 20px rgba(0,0,0,0.05),
				inset -10px -10px 15px rgba(255,255,255,0.9); */
			box-shadow: 
				inset 15px 15px 15px 5px #0007, 
				/* 15px 15px 15px -6px #fff, */
				/* 15px 25px 15px -5px #0005,  */
				15px 25px 15px -15px #0005, 
				inset -5px -5px 15px 5px #fffd,
				inset -50px -50px 20px 20px #fff5
				;

			border-radius: 60% 50% 60% 50% / 60% 60% 50% 50%;
			transform-origin: 0% 0%;

			&::before, &::after {
				content: "";
				position: absolute;
				background: radial-gradient(#fff 70%, #fff0);
				border-radius: 50%;
				filter: drop-shadow(6px 1px 3px #fffa) drop-shadow(-6px 1px 3px #fffa);
			}

			&::before {
				top: 25px;
				left: 20px;
				width: 40px;
				height: 15px;
				transform: rotate(-38deg);
			}

			&::after {
				top: 10px;
				left: 65px;
				width: 10px;
				height: 10px;
				transform: rotate(-30deg) skew(-6deg, 19deg);
				box-shadow: -5px 135px 10px 10px #fff1;
			}
		}
	}
  </style>
</head>
<body>
	<canvas id="glcanvas"></canvas>
	<div class="glass">
		<div class="drops"></div>
	</div>
</body>
<script>
	const drops = document.querySelector(".drops")
	const width = drops.getBoundingClientRect().width
	const height = drops.getBoundingClientRect().height
	const dropSize = 150
	const max = Math.ceil(width * height / Math.pow(dropSize, 2))
	const skewRange = 20
	const whRange = 20
	const getRandSize = range => Math.ceil(Math.random() * range) - range / 2

	const createDrop = (scale, left, top) => 
		document.querySelector(".drops").insertAdjacentHTML("beforeend", `
			<div class="drop" style="
				transform: scale(${scale}) skew(${getRandSize(skewRange)}deg, ${getRandSize(skewRange)}deg);
				top: ${top}px;
				left: ${left}px;
				width: ${dropSize + getRandSize(whRange)}px;
				height: ${dropSize + getRandSize(whRange)}px;
			"></div>
		`)
	const check = (scale, x3, y3) => {
		const drops = document.querySelectorAll(".drops .drop")
		for(let i = 0; i < drops.length; i++) {
			const x1 = drops[i].getBoundingClientRect().x
			const x2 = x1 + drops[i].getBoundingClientRect().width
			
			const y1 = drops[i].getBoundingClientRect().y
			const y2 = y1 + drops[i].getBoundingClientRect().height
			
			const x4 = x3 + dropSize * scale
			const y4 = y3 + dropSize * scale
			
			if(x3 < x2 && x1 < x4 && y3 < y2 && y1 < y4) return false
		}
		return true
	}

	const checkNdrop = () => {
		let left, top
		const setXY = () => {
			left = Math.random() * width
			top = Math.random() * height
		}
		const scale = Math.random() / 10
		setXY()
		if(check(scale, left, top)) createDrop(scale, left, top)
	}

	let rainDelay = 1000
	let speed = 1
	async function run(max) {
		for(const item of Array(Math.ceil(max))) {
			await new Promise(resolve => setTimeout(resolve, Math.max(50, rainDelay)))
			checkNdrop()
			if(rainDelay > 0) {
				speed *= 2
				rainDelay -= speed
			}
		}
		confirm("빗방울 생성 한계에 도달했습니다.\r추가 생성하시겠습니까?\r※ 과부하 위험이 있습니다.") ? run(width * height) : {}
	}
	run(width / dropSize * height / dropSize * 10)

	const img = "vecteezy_rainy-day-in-the-forest_60289806.jpeg"

	const vertexShaderSource = `
		attribute vec2 aPosition;
		varying vec2 vUV;
		void main() {
			vUV = (aPosition + 1.0) * 0.5;
			gl_Position = vec4(aPosition, 0.0, 1.0);
		}
	`;

	const fragmentShaderSource = `
		precision mediump float;
		uniform sampler2D uTexture;
		uniform float distortionStrength;
		varying vec2 vUV;

		void main() {
			vec2 center = vec2(0.5, 0.5);
			// vec2 delta = vUV - center;
			// 좌우반전
			vec2 flip = vec2(1.0 - vUV.x, vUV.y);
			vec2 delta = flip - center;
			float r = length(delta);
			// 거리기반 왜곡
			vec2 distortedUV = center + delta * (1.0 + distortionStrength * pow(r, 2.5)) - 0.5 * r;
			gl_FragColor = texture2D(uTexture, distortedUV);
		}
	`;

	function createShader(gl, type, source) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error("Shader compile error:", gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
			return null;
		}
		return shader;
	}

	function createProgram(gl, vsSource, fsSource) {
		const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
		const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
		const program = gl.createProgram();
		gl.attachShader(program, vs);
		gl.attachShader(program, fs);
		gl.linkProgram(program);
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			console.error("Program link error:", gl.getProgramInfoLog(program));
			return null;
		}
		return program;
	}

	function main() {
		const canvas = document.getElementById("glcanvas");
		const gl = canvas.getContext("webgl");
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
		gl.useProgram(program);

		const positionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		const positions = new Float32Array([
			-1, -1,  1, -1,  -1, 1,
			1, -1,  1,  1,  -1, 1
		]);
		gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

		const aPosition = gl.getAttribLocation(program, "aPosition");
		gl.enableVertexAttribArray(aPosition);
		gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

		const texture = gl.createTexture();
		const image = new Image();
		image.src = img;
		image.onload = () => {
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false); // 상하반전 설정
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

			const uTexture = gl.getUniformLocation(program, "uTexture");
			const distortionStrength = gl.getUniformLocation(program, "distortionStrength");

			gl.uniform1i(uTexture, 0);
			gl.uniform1f(distortionStrength, -5.0); // 왜곡 강도 조절

			gl.viewport(0, 0, canvas.width, canvas.height);
			gl.clearColor(0, 0, 0, 1);
			gl.clear(gl.COLOR_BUFFER_BIT);
			gl.drawArrays(gl.TRIANGLES, 0, 6);
			
			const dataURL = canvas.toDataURL("image/png")
			document.querySelector("head").insertAdjacentHTML("beforeend", `<style>
				.drop {
					background: url(${dataURL}) center / cover;
				}
				.glass {
					background: url(${img}) center / cover;
				}
				</style>`
			)
		};
	}

	main();
</script>
</html>
